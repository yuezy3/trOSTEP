\chapter{操作系统介绍}
如果你在上本科操作系统的课程，那你应该具有计算机程序运行是做什么的基本概念了。
如果不是，这本书（和相应的课程）对你就会相当难。---所以你也许应该停止阅读本书了，或者是
在继续之前跑到附近的书店补充必要的背景知识（Patt/Patel\citeholder{PP03}和
Bryant/O'Hallaron\citeholder{BOH10}都是很棒的书）。

所以，当程序运行是究竟发生了什么？

一个运行的程序会做一件相当简单的事情：它执行指令。每秒执行几百万条（当今，甚至是十几亿条）指
令，处理器从内存中\mkidx{fetches}{取指}，
\mkidx{decodes}{解码}指令（例如：搞清这是条什么指令），然后
\mkidx{executes}{执行}指令（例如：做被设定好要做的事，比如把两个数
加到一起，访问内存，检查条件，跳到一个函数出，等等）。在执行完这条指令，处理器就接着执
行下一条指令，然后如此这般，直到整个程序最终运行
完毕\footnote{当然，现代处理器在这面罩下还做着相当多的奇怪骇人的事情来使得
	程序运行的更快，例如，一次运行多条指令，甚至不按序发出和完成这些指令！但这不是我们在这
	里关心的重点；我们只需关心大多数程序所假设的简单模型：指令在表面上有序线性地一条接一条
	的执行，}

在这里，我们刚刚描述了基本的
\mkidx{Von Neumann}{冯诺依曼}计算模
型\footnote{冯诺依曼是早期计算机系统的先驱。他也在博弈论和原子弹方面做了先驱工作，
	在NBA还打了6年的球。好吧，其中的一些事不是真的。}
听起来挺简单的，是吧？但是在这门课上，我们会学习到当一个程序运行时，为了达到让系统
\mkidx{easy to use}{易于使用}的基本目标，有许多不平凡
的事情在进行着。

事实上，有一个软件主体负责让运行程序更简单（甚至允许你在同一时间无缝的运行多个程序），
允许程序共享内存，使程序能和设备互动，以及其他的一些像这样的有趣事情。这个程序主体
被称作
\mkidx{operating system}{操作系统}（或简写为\mkidx{OS}{OS}）\footnote{操作系统
	的一个早期名字是\mkidx{supervisor}{监管器} (supervisor)或者甚至叫做
	\mkidx{master control program}{主控制程序}。} ，因为它确保系统以易于使用的方
式正确有效的运行。\index[crux]{如何虚拟化}

\begin{mycrux}{How to virtualize resources}{症结：如何虚拟化资源} %
	一个我们要在本书回答的中心问题很简单：操作系统是怎么虚拟化资源的？这是我们
	问题的症结。操作系统为什么要这么做（虚拟化资源）不是主要问题。因为答案是
	显然的：这会使系统更易于使用。因此，我们将注意力集中在怎么做上面：为了实现
	虚拟化，操作系统实现了什么机制和策略？操作系统是怎么做的这么高效的？需要
	什么硬件支持？
	
	我们将会在想这样的阴影盒子里面写“问题的症结”，作为一种突出在解决构建操作系统时
	遇到的问题的方式。因此，在一个特定的主题下的笔记里，你可能会发现一个或多个
	这样用来突出问题的症结盒子。当然，章节里面的详细内容将会给出解决方法，至少是
	给出解决方法的规范。
\end{mycrux}

操作系统做到这个的基本方法是采用一种叫做\mkidx{virtualization}{虚拟化}的通用技术。
换句话说，操作系统接手\mkidx{physical}{物理}资源（像处理器，内存，磁盘）然后将它们
转换为一种更一般、更强大更易于使用的\mkidx{virtual}{虚拟}资源形式。正因为这个，我们
有时也把操作系统叫做\mkidx{virtual machine}{虚拟机}。

当然，为了让用户能告诉操作系统做什么，让用户能使用虚拟机提供的功能（如运行一个程序，
分配一些内存，访问一个文件），操作系统必须提供一些能让你调用的接口(APIs)。事实上，
一个典型的操作系统公开几百个\mkidx{system calls}{系统调用}供应用程序使用。因为
操作系统提供了这些运行程序、访问内存和设备以及相关的行为的调用接口，我们有时也说
操作系统提供了一个\mkidx{standard library}{标准库}给应用程序。

最后，因为虚拟化允许多个程序运行（因此共享CPU），多个程序并行访问他们的结构和数据（因此
共享内存），多个程序访问设备（因此共享磁盘等），操作系统有时也叫作
\mkidx{resource manager}{资源管理器}。所有这些CPU，内存，磁盘都是系统的
\mkidx{resource}{资源}；操作系统的角色就是去\mkidx{manage}{管理}这些资源，而且尽可能
做的高效，公平或满足许多其他的可能目标。为了更进一步了解操作系统的角色，让我们看看具体的
例子。

\begin{figure}[tbh]
	\linespread{1}
	\lstset{style=customc}
	\lstinputlisting{./tex/chapter02/simplecode.c}
	\caption{示例：循环并打印的一段代码}
	\label{simplecode}
\end{figure}

\section{虚拟化CPU}
图\ref{simplecode}呈现了我们第一个程序。这个程序没做很多事情。事实上，它就是调用了
\lstinline!Spin()!，一个不停查看时间，并在满了1秒钟后返回。然后打印出一个用户通过命令行
传入的字符串，如此这样重复再重复。

假设我们把这个文件保存为\texttt{cpu.c}然后在单CPU的系统上编译运行它，那我们就可以看到：

\begin{lstlisting}[basicstyle=\ttfamily]
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
^C
prompt>
\end{lstlisting}

并不是一次很有趣的运行 --- 系统开始运行程序，这个程序不停的检查时间，直到时间流逝了一秒钟。一旦
时间过去了一秒，程序吧用户传入的字符串（这里是字母“A"）打印出来，然后继续。这个程序将会不停的
运行下去，直到按下“Ctrl-C”（这个快捷键是UNIX类系统终止前台运行程序用的）我们才能终止这个程序。
\cite{RichardP.Feynman2011}









\phantomsection
\printbibliography[heading=subbibintoc,title={引用文献}]












